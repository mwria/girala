import telebot
import mysql.connector
import random
from telebot import types
import time

bot = telebot.TeleBot("6127981599:AAHBe-NzKCLiE7xAn8iI8Kw2DQHG_SDlu1M")


def db_config():
    return {
        'host': '26.121.107.216',
        'database': 'girala',
        'user': 'maria',
        'password': '13243122'
    }


def main():
    @bot.callback_query_handler(func=lambda call: call.data.startswith('subcategoria_'))
    def subcategoria_callback(call):
        subcategoria = call.data.replace('subcategoria_', '')
        gerar_carta_sorteada(subcategoria, call.message.chat.id)

    @bot.message_handler(commands=['iduser'])
    def handle_iduser_command(message):
        user_id = message.from_user.id
        bot.reply_to(message, f"Seu ID de usu√°rio √©: {user_id}")

    def consultar_personagem_por_nome(nome):
        try:
            con = mysql.connector.connect(**db_config())
            cursor = con.cursor()

            query = "SELECT id, nome, imagem FROM personagens WHERE nome LIKE %s"
            cursor.execute(query, (f"%{nome}%",))
            result = cursor.fetchone()

            # Descartar resultados n√£o lidos
            cursor.fetchall()

            if result:
                id, nome, imagem = result
                return f"ID: {id}\nNome: {nome}\n", imagem

            else:
                return "Nenhum resultado encontrado para o nome fornecido."

        except mysql.connector.Error as err:
            return f"Erro ao executar a consulta: {err}"

        finally:
            if 'cursor' in locals():
                cursor.close()
            if 'con' in locals():
                con.close()



def execute_query(query):
    conn = mysql.connector.connect(**db_config())
    cursor = conn.cursor()
    cursor.execute(query)
    result = cursor.fetchall()
    cursor.close()
    conn.close()
    return result


def buscar_categorias():
    try:
        conn = mysql.connector.connect(**db_config())
        cursor = conn.cursor()

        cursor.execute('SELECT DISTINCT categoria FROM personagens')

        categorias = [row[0] for row in cursor.fetchall()]

        return categorias

    except mysql.connector.Error as err:
        print(f"Erro ao buscar categorias: {err}")
        return []

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


def consultar_dados(id):
    try:
        con = mysql.connector.connect(**db_config())
        cursor = con.cursor()

        query = "SELECT id, nome, imagem, subcategoria FROM personagens WHERE id = %s"
        cursor.execute(query, (id,))
        result = cursor.fetchone()

        # Descartar resultados n√£o lidos
        cursor.fetchall()

        if result:
            id, nome, imagem, subcategoria = result
            return f"üíå | Personagem:\n\n{id}. {nome} \nde {subcategoria}", imagem, nome, subcategoria
        else:
            return "Nenhum resultado encontrado para o ID fornecido.", None, None, None

    except mysql.connector.Error as err:
        return f"Erro ao executar a consulta: {err}", None, None, None

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'con' in locals():
            con.close()


def consultar_personagens_subcategoria(subcategoria):
    try:
        con = mysql.connector.connect(**db_config())
        cursor = con.cursor()

        query = "SELECT id, nome FROM personagens WHERE subcategoria = %s"
        cursor.execute(query, (subcategoria,))
        results = cursor.fetchall()

        if results:
            lista_personagens = [f"{id}. {nome}" for id, nome in results]
            return lista_personagens

        else:
            return "Nenhum resultado encontrado para a subcategoria fornecida."

    except mysql.connector.Error as err:
        return f"Erro ao executar a consulta: {err}"

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'con' in locals():
            con.close()


def consultar_personagens_por_subcategoria(subcategoria):
    try:
        con = mysql.connector.connect(**db_config())
        cursor = con.cursor()

        query = "SELECT id, nome FROM personagens WHERE subcategoria = %s"
        cursor.execute(query, (subcategoria,))
        results = cursor.fetchall()

        if results:
            lista_personagens = [f"{id}. {nome}" for id, nome in results]
            return lista_personagens

        else:
            return "Nenhum resultado encontrado para a subcategoria fornecida."

    except mysql.connector.Error as err:
        return f"Erro ao executar a consulta: {err}"

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'con' in locals():
            con.close()

def verificar_usuario_diferente():
    try:
        conn = mysql.connector.connect(**db_config())
        cursor = conn.cursor()

        query = "SELECT u.id_usuario, i.id_usuario FROM usuarios u JOIN inventario i ON u.id_usuario = i.id_usuario"
        cursor.execute(query)

        result = cursor.fetchall()

        for row in result:
            id_usuario_usuarios = row[0]
            id_usuario_inventario = row[1]

            if id_usuario_usuarios != id_usuario_inventario:
                return True

        return False

    except mysql.connector.Error as err:
        print(f"Erro ao verificar usu√°rio na tabela inventario: {err}")

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

def buscar_cartas_usuario(id_usuario):
    try:
        id_usuario = message.from_user.id
        conn = mysql.connector.connect(**db_config())
        cursor = conn.cursor()

        # Consulta SQL para buscar os IDs das cartas relacionadas ao ID do usu√°rio
        query = f"SELECT id_personagem FROM inventario WHERE id_usuario = {id_usuario}"
        cursor.execute(query)

        # Lista para armazenar os IDs das cartas
        cartas_usuario = []

        # Obt√©m os resultados da consulta e adiciona os IDs das cartas √† lista
        for row in cursor.fetchall():
            id_carta = row[0]
            cartas_usuario.append(id_carta)

        return cartas_usuario

    except mysql.connector.Error as err:
        print(f"Erro ao buscar cartas do usu√°rio: {err}")

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

def consultar_personagem_por_nome(nome: object) -> object:
    try:
        con = mysql.connector.connect(**db_config())
        cursor = con.cursor()

        query = "SELECT id, nome, imagem, subcategoria FROM personagens WHERE nome LIKE %s"
        cursor.execute(query, (f"%{nome}%",))
        result = cursor.fetchone()

        # Descartar resultados n√£o lidos
        cursor.fetchall()

        if result:
            id, nome, imagem, subcategoria = result
            return f"üíå | Personagem:\n\n{id}. {nome} \nde {subcategoria}", imagem

        else:
            return "Nenhum resultado encontrado para o nome fornecido."

    except mysql.connector.Error as err:
        return f"Erro ao executar a consulta: {err}"

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'con' in locals():
            con.close()




def obter_carta_aleatoria(subcategoria, banco_de_dados):
    # Verificar se o usu√°rio da tabela "usuarios" √© diferente do da tabela "inventario"
    if verificar_usuario_diferente():
        # Gerar uma carta aleat√≥ria apenas para o usu√°rio da tabela "usuarios"
        query = "SELECT nome FROM usuarios ORDER BY RAND() LIMIT 1"
    else:
        # Gerar uma carta aleat√≥ria para qualquer usu√°rio
        query = "SELECT nome FROM usuarios JOIN inventario ON usuarios.id_usuario = inventario.id_usuario ORDER BY RAND() LIMIT 1"

    cartas_disponiveis = [carta for carta in banco_de_dados if carta['subcategoria'] == subcategoria]
    carta_aleatoria = random.choice(cartas_disponiveis)

    # Executar a consulta SQL para obter a carta aleat√≥ria
    resultado = executar_consulta_sql(query)
    if resultado:
        carta_aleatoria['nome'] = resultado[0]['nome']

    return carta_aleatoria
def obter_cartas_por_subcategoria(subcategoria, conn):
    cursor = conn.cursor()
    query = "SELECT id, nome, imagem FROM personagens WHERE subcategoria = %s"
    cursor.execute(query, (subcategoria,))
    result = cursor.fetchall()
    cursor.close()
    return result

def ler_botao_e_buscar_carta(numero_botao, texto, message):
    try:
        conn = mysql.connector.connect(**db_config())
        cursor = conn.cursor()

        # Extrair a subcategoria do texto
        subcategoria = texto.split('-')[1].strip()

        # Buscar cartas com a subcategoria correspondente
        query = "SELECT id, nome, imagem FROM cartas WHERE subcategoria = %s"
        cursor.execute(query, (subcategoria,))
        cartas = cursor.fetchall()

        if cartas:
            # Selecionar uma carta aleat√≥ria
            carta_aleatoria = random.choice(cartas)
            id_carta, nome_carta, imagem_carta = carta_aleatoria

            resposta = f"Carta encontrada:\nID: {id_carta}\nNome: {nome_carta}"

            # Enviar a imagem da carta
            with open(imagem_carta, 'rb') as photo:
                bot.send_photo(message.chat.id, photo, caption=resposta)

        else:
            bot.send_message(message.chat.id, f"Nenhuma carta encontrada para a subcategoria '{subcategoria}'.")

    except mysql.connector.Error as err:
        bot.send_message(message.chat.id, f"Erro ao buscar cartas: {err}")

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

def buscar_subcategorias(categoria, user_id=None):
    try:
        conn = mysql.connector.connect(**db_config())
        cursor = conn.cursor()

        if categoria == 'geral':
            cursor.execute('SELECT DISTINCT subcategoria FROM personagens')
        elif user_id is None:
            cursor.execute('SELECT DISTINCT subcategoria FROM personagens WHERE categoria = %s', (categoria,))
        else:
            cursor.execute('SELECT DISTINCT subcategoria FROM personagens WHERE categoria = %s AND user_id != %s',
                           (categoria, user_id))

        subcategorias = [row[0] for row in cursor.fetchall()]

        return subcategorias

    except mysql.connector.Error as err:
        print(f"Erro ao buscar subcategorias: {err}")
        return []

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

categorias = buscar_categorias()

# Fun√ß√£o para verificar se o ID do usu√°rio j√° existe na tabela 'usuarios'
def verificar_id_usuario(id_usuario):
    try:
        conn = mysql.connector.connect(**db_config())
        cursor = conn.cursor()

        # Verificar se o ID do usu√°rio existe na tabela 'usuarios'
        query = "SELECT * FROM usuarios WHERE id_usuario = %s"
        cursor.execute(query, (id_usuario,))
        resultado = cursor.fetchone()

        return resultado is not None

    except mysql.connector.Error as err:
        print(f"Erro ao verificar ID do usu√°rio: {err}")

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# Fun√ß√£o para verificar se o nome de usu√°rio j√° existe na tabela 'usuarios'
def verificar_nome_usuario(nome_usuario):
    try:
        conn = mysql.connector.connect(**db_config())
        cursor = conn.cursor()

        # Verificar se o nome de usu√°rio j√° existe na tabela 'usuarios'
        query = "SELECT * FROM usuarios WHERE nome_usuario = %s"
        cursor.execute(query, (nome_usuario,))
        resultado = cursor.fetchone()

        return resultado is not None

    except mysql.connector.Error as err:
        print(f"Erro ao verificar nome de usu√°rio: {err}")

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

# Comando /setuser
@bot.message_handler(commands=['setuser'])
def setuser_comando(message):
    # Verificar se o ID do usu√°rio j√° existe na tabela 'usuarios'
    if verificar_id_usuario(message.from_user.id):
        bot.send_message(message.chat.id, "Seu ID de usu√°rio j√° est√° registrado.")
        bot.send_message(message.chat.id, "Por favor, digite um nome de usu√°rio √∫nico:")
        bot.register_next_step_handler(message, processar_nome_usuario)
    else:
        bot.send_message(message.chat.id, "Por favor, execute o comando /start primeiro.")

# Fun√ß√£o para processar o nome de usu√°rio digitado pelo usu√°rio
def processar_nome_usuario(message):
    nome_usuario = message.text.strip()

    # Verificar se o nome de usu√°rio j√° existe na tabela 'usuarios'
    if verificar_nome_usuario(nome_usuario):
        bot.send_message(message.chat.id, "O nome de usu√°rio j√° est√° em uso.")
        bot.send_message(message.chat.id, "Por favor, escolha um nome de usu√°rio diferente:")
        bot.register_next_step_handler(message, processar_nome_usuario)
    else:
        try:
            conn = mysql.connector.connect(**db_config())
            cursor = conn.cursor()

            # Atualizar a coluna 'nome_usuario' com o nome fornecido
            query = "UPDATE usuarios SET nome_usuario = %s WHERE id_usuario = %s"
            cursor.execute(query, (nome_usuario, message.from_user.id))
            conn.commit()

            bot.send_message(message.chat.id, f"O nome de usu√°rio '{nome_usuario}' foi registrado com sucesso.")

        except mysql.connector.Error as err:
            bot.send_message(message.chat.id, f"Erro ao registrar nome de usu√°rio: {err}")

        finally:
            if 'cursor' in locals():
                cursor.close()
            if 'conn' in locals():
                conn.close()

# Fun√ß√£o para registrar o ID do usu√°rio na tabela 'usuarios'
def registrar_usuario(id_usuario):
    try:
        conn = mysql.connector.connect(**db_config())
        cursor = conn.cursor()

        # Verificar se o ID do usu√°rio j√° est√° registrado
        query = "SELECT * FROM usuarios WHERE id_usuario = %s"
        cursor.execute(query, (id_usuario,))
        resultado = cursor.fetchone()

        if resultado:
            # O ID do usu√°rio j√° est√° registrado, nada precisa ser feito
            return

        # Registrar o ID do usu√°rio na tabela 'usuarios'
        query = "INSERT INTO usuarios (id_usuario) VALUES (%s)"
        cursor.execute(query, (id_usuario,))
        conn.commit()

    except mysql.connector.Error as err:
        print(f"Erro ao registrar usu√°rio: {err}")

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


def buscar_carta_aleatoria_por_subcategoria(subcategoria):
    try:
        conn = mysql.connector.connect(**db_config())
        cursor = conn.cursor()

        query = "SELECT id, nome, imagem FROM personagens WHERE subcategoria = %s ORDER BY RAND() LIMIT 1"
        cursor.execute(query, (subcategoria,))
        resultado = cursor.fetchone()

        return resultado

    except mysql.connector.Error as err:
        print(f"Erro ao buscar carta por subcategoria: {err}")

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()

@bot.message_handler(commands=['start'])
def start_comando(message):
    # Registrar o ID do usu√°rio na tabela 'usuarios'
    registrar_usuario(message.from_user.id)
    keyboard = telebot.types.InlineKeyboardMarkup()
    image_path = "imagens/Normal/halsey.jpeg"  # Defina o caminho correto para a imagem
    with open(image_path, 'rb') as photo:
        bot.send_photo(message.chat.id, photo, caption='Seja muito bem vindo ao giral√°! entre e fique a vontade',
                       reply_markup=keyboard)
def gid_command(message):
    try:
        conn = mysql.connector.connect(**db_config())
        cursor = conn.cursor()

        # Extract the ID of the card from the received message
        id = message.text.replace('/gid', '').strip()

        # Query the card data by ID
        resposta, imagem, nome, subcategoria = consultar_dados(id)

        if resposta is not None:
            # Send the response to the user
            bot.send_message(chat_id=message.chat.id, text=resposta)

            # Get the ID of the user who triggered the command
            user_id = message.from_user.id

            # Check if the card already exists in the user's inventory
            cursor.execute("SELECT * FROM inventario WHERE id_personagem = %s AND id_usuario = %s", (id, user_id))
            existing_row = cursor.fetchone()

            if existing_row is not None:
                # Increment the quantity of the existing card
                add_to_inventory(cursor, conn, id, user_id, nome, subcategoria)
                bot.send_message(message.chat.id, "Quantidade atualizada no invent√°rio: {}".format(existing_row[4] + 1))
            else:
                # Register the new card in the user's inventory
                add_to_inventory(cursor, conn, id, user_id, nome, subcategoria)
                bot.send_message(message.chat.id, "Carta registrada no invent√°rio com sucesso!")

            # Send the image if available
            if imagem is not None:
                with open(imagem, 'rb') as photo:
                    bot.send_photo(chat_id=message.chat.id, photo=photo)
        else:
            bot.send_message(chat_id=message.chat.id, text="Nenhum dado encontrado para o ID informado.")

    except mysql.connector.Error as err:
        bot.send_message(message.chat.id, f"Erro ao buscar dados da carta: {err}")

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


def add_to_inventory(cursor, conn, id_personagem, id_usuario, nome, subcategoria):
    try:
        # Check if the card already exists in the user's inventory
        cursor.execute("SELECT * FROM inventario WHERE id_personagem = %s AND id_usuario = %s", (id_personagem, id_usuario))
        existing_row = cursor.fetchone()

        if existing_row is not None:
            # Increment the quantity of the existing card
            cursor.execute("UPDATE inventario SET quantidade = quantidade + 1 WHERE id_personagem = %s AND id_usuario = %s", (id_personagem, id_usuario))
            conn.commit()
        else:
            # Register the new card in the user's inventory
            cursor.execute("INSERT INTO inventario (id_personagem, id_usuario, nome, subcategoria, quantidade) VALUES (%s, %s, %s, %s, 1)", (id_personagem, id_usuario, nome, subcategoria))
            conn.commit()

    except mysql.connector.Error as err:
        bot.send_message(message.chat.id, f"Erro ao adicionar carta ao banco de dados: {err}")

@bot.message_handler(commands=['gnome'])
def gnome_command(message):
    nome = message.text.replace('/gnome', '').strip()

    if nome:
        resposta, imagem = consultar_personagem_por_nome(nome)  # Passa o objeto message como par√¢metro
        if imagem is not None:
            with open(imagem, 'rb') as photo:
                bot.send_photo(chat_id=message.chat.id, photo=photo, caption=resposta)
        else:
            bot.send_message(chat_id=message.chat.id, text=resposta)
    else:
        bot.send_message(chat_id=message.chat.id, text="O comando /gnome deve ser acompanhado de um nome.")



@bot.callback_query_handler(func=lambda call: call.data.startswith('categoria_'))
def categoria_callback(call):
    categoria = call.data.replace('categoria_', '')

    subcategorias = buscar_subcategorias(categoria)
    subcategorias = [subcategoria for subcategoria in subcategorias if subcategoria]

    if subcategorias:
        keyboard = telebot.types.InlineKeyboardMarkup()

        for subcategoria in subcategorias:
            button = telebot.types.InlineKeyboardButton(subcategoria, callback_data='subcategoria_' + subcategoria)
            keyboard.add(button)

        try:
            bot.edit_message_text('Selecione uma subcategoria:', call.message.chat.id, call.message.message_id,
                                  reply_markup=keyboard)
        except telebot.apihelper.ApiTelegramException:
            pass
    else:
        bot.send_message(call.message.chat.id, "Nenhuma subcategoria encontrada para a categoria selecionada.")


def gerar_carta_sorteada(subcategoria, chat_id):
    try:
        conn = mysql.connector.connect(**db_config())
        cursor = conn.cursor()

        query = "SELECT id, nome, imagem FROM cartas WHERE subcategoria = %s"
        cursor.execute(query, (subcategoria,))
        cartas = cursor.fetchall()

        if cartas:
            carta_aleatoria = random.choice(cartas)
            id_carta, nome_carta, imagem_carta = carta_aleatoria

            resposta = f"Carta encontrada:\nID: {id_carta}\nNome: {nome_carta}"

            with open(imagem_carta, 'rb') as photo:
                bot.send_photo(chat_id, photo, caption=resposta)

        else:
            bot.send_message(chat_id, f"Nenhuma carta encontrada para a subcategoria '{subcategoria}'.")

    except mysql.connector.Error as err:
        bot.send_message(chat_id, f"Erro ao buscar cartas: {err}")

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


@bot.message_handler(commands=['ggirar'])
def ggirar(message):
    keyboard = telebot.types.InlineKeyboardMarkup()

    # Primeira coluna
    primeira_coluna = [
        telebot.types.InlineKeyboardButton(text="üçÉ  M√∫sica", callback_data='ggirar_musica'),
        telebot.types.InlineKeyboardButton(text="üçÑ  Filmes", callback_data='ggirar_filmes'),
        telebot.types.InlineKeyboardButton(text="üçÅ  Jogos", callback_data='ggirar_jogos')
    ]

    # Segunda coluna
    segunda_coluna = [
        telebot.types.InlineKeyboardButton(text="ü™π  Animanga", callback_data='ggirar_animanga'),
        telebot.types.InlineKeyboardButton(text="ü™®  S√©ries", callback_data='ggirar_series'),
        telebot.types.InlineKeyboardButton(text="üåæ  Miscel√¢nea", callback_data='ggirar_miscelanea')
    ]

    keyboard.add(*primeira_coluna)
    keyboard.add(*segunda_coluna)

    # Bot√£o "Geral"
    keyboard.row(telebot.types.InlineKeyboardButton(text="ü´ß  Geral", callback_data='ggirar_geral'))

    # Imagem
    image_path = "imagens/Normal/halsey.jpeg"  # Defina o caminho correto para a imagem
    with open(image_path, 'rb') as photo:
        bot.send_photo(message.chat.id, photo, caption='Selecione uma categoria:', reply_markup=keyboard)


@bot.callback_query_handler(func=lambda call: True)
def callback_handler(call):
    print("callback", call.data)
    message = call.message
    conn = mysql.connector.connect(**db_config())
    cursor = conn.cursor()
    id_usuario = message.from_user.id

    if call.message:
        if call.data.startswith('ggirar_'):
            categoria = call.data.replace('ggirar_', '')
            categoria_handler(call.message, categoria)

        elif call.data.startswith('gmusica'):
            subcategoria = call.data.replace('gmusica_', '')
            id_personagem_query = "SELECT id FROM personagens WHERE subcategoria = %s"
            cursor.execute(id_personagem_query, (subcategoria,))
            results = cursor.fetchall()
            id_personagem = results[0][0]

            subcategoria_handler(message, subcategoria, cursor, conn, id_personagem, id_usuario)


@bot.message_handler(commands=['armazem'])
@bot.message_handler(commands=['armazem'])
def armazem_command(message):
    conn = mysql.connector.connect(**db_config())
    cursor = conn.cursor()

    # Obt√©m o ID do usu√°rio que acionou o comando
    id_usuario = message.from_user.id

    # Busca as cartas do usu√°rio
    cartas_usuario = buscar_cartas_usuario(id_usuario)

    # Verifica se o usu√°rio possui cartas
    if cartas_usuario:
        resposta = "üíå | Cartas no armaz√©m:\n"
        for id_carta in cartas_usuario:
            # Consulta SQL para obter os dados da carta
            query = f"SELECT nome, subcategoria, quantidade FROM inventario WHERE id_personagem = {id_carta} AND id_usuario = {id_usuario}"
            cursor.execute(query)
            carta = cursor.fetchone()

            nome_carta = carta[0]
            subcategoria_carta = carta[1]
            quantidade_carta = carta[2]

            # Verifica√ß√£o da quantidade
            if quantidade_carta is None:
                quantidade_carta = 0

            # Mapear a quantidade para as letras correspondentes com espa√ßamento
            if quantidade_carta == 1:
                letra_quantidade = "üçÄ"
            elif 2 <= quantidade_carta <= 4:
                letra_quantidade = "üçÑ"
            elif 5 <= quantidade_carta <= 9:
                letra_quantidade = "üïØ"
            elif 10 <= quantidade_carta <= 19:
                letra_quantidade = "ü´ê"
            elif 20 <= quantidade_carta <= 29:
                letra_quantidade = "üßö‚Äç‚ôÄÔ∏è"
            elif 30 <= quantidade_carta <= 39:
                letra_quantidade = "üåô"
            elif 40 <= quantidade_carta <= 49:
                letra_quantidade = "üîÆ"
            elif 50 <= quantidade_carta <= 99:
                letra_quantidade = "üëë"
            else:
                letra_quantidade = "üëë"

            resposta += f" {id_carta} - {nome_carta} de {subcategoria_carta} {letra_quantidade} \n"

        bot.send_message(message.chat.id, resposta)
    else:
        bot.send_message(message.chat.id, "Voc√™ n√£o possui cartas no armaz√©m.")
def categoria_handler(message, categoria):
    try:
        conn = mysql.connector.connect(**db_config())
        cursor = conn.cursor()

        subcategorias = buscar_subcategorias(categoria)

        subcategorias = [subcategoria for subcategoria in subcategorias if subcategoria]

        if subcategorias:
            resposta = "E o universo sorteou:\n\n"
            subcategorias_aleatorias = random.sample(subcategorias, min(4, len(subcategorias)))

            keyboard = telebot.types.InlineKeyboardMarkup()

            for i in range(0, 4):
                button = telebot.types.InlineKeyboardButton(text=subcategorias_aleatorias[i], callback_data="gmusica_"+subcategorias_aleatorias[i])
                keyboard.add(button)

            bot.send_message(message.chat.id, resposta, reply_markup=keyboard)

        else:
            bot.send_message(message.chat.id, f"Nenhuma subcategoria encontrada para a categoria '{categoria}'.")

    except mysql.connector.Error as err:
        bot.send_message(message.chat.id, f"Erro ao buscar subcategorias: {err}")

    finally:
        if 'cursor' in locals():
            cursor.close()
        if 'conn' in locals():
            conn.close()


def subcategoria_handler(message, subcategoria, cursor, conn, id_personagem, id_usuario):
    print('subcategoria_handler', subcategoria)

    cartas_disponiveis = obter_cartas_por_subcategoria(subcategoria, conn)

    if cartas_disponiveis:
        carta_aleatoria = random.choice(cartas_disponiveis)
        id, nome, imagem = carta_aleatoria

        add_to_inventory(cursor, conn, id_personagem, id_usuario, nome, subcategoria)

        if imagem is None:
            bot.send_message(message.chat.id, f"{nome} - (A carta n√£o tem imagem)")
        elif imagem.startswith('imagens/'):
            with open(imagem, 'rb') as photo:
                bot.send_photo(message.chat.id, photo, caption=nome)
        else:
            bot.send_message(message.chat.id, f"{nome}\n{imagem}")
    else:
        bot.send_message(message.chat.id, f"Nenhuma carta encontrada na subcategoria '{subcategoria}'.")


@bot.callback_query_handler(func=lambda call: True)
def callback_handler(call):
    numero_selecionado = call.data

    subcategorias = buscar_subcategorias("musica")
    subcategorias = [subcategoria for subcategoria in subcategorias if subcategoria]

    if int(numero_selecionado) in range(1, len(subcategorias) + 1):
        texto_selecionado = subcategorias[int(numero_selecionado) - 1]
        resposta = f"Voc√™ selecionou o n√∫mero {numero_selecionado} - {texto_selecionado}."
    else:
        resposta = "Op√ß√£o inv√°lida."

    bot.answer_callback_query(call.id, resposta)



bot.polling()

if __name__ == "__main__":
    main()
